package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path"
	"strings"
	"text/template"

	"github.com/nfx/slrp/ql/generator/meta"
)

const tmpl = `// Code generated by go run github.com/nfx/slrp/ql/generator/main.go Foo. DO NOT EDIT.
package {{.Type.Package}}

{{if ev }}
import (
	"github.com/nfx/slrp/ql/eval"
)
{{end}}

type {{.Type.Name}}Dataset []{{.Type.Name}}

func (d {{.Type.Name}}Dataset) Query(query string) (*{{ev}}QueryResult[{{.Type.Name}}], error) {
	return (&{{ev}}Dataset[{{.Type.Name}}]{
		Source: d,
		Accessors: {{ev}}Accessors{
			{{range .Type.Fields -}}
				{{FieldTemplate "accessor" .}}
			{{end}}
		},
		Sorters: {{ev}}Sorters[{{.Type.Name}}]{
			{{range .Type.Fields -}}
				"{{.Name}}": {Asc: d.sortAsc{{.Name}}, Desc: d.sortDesc{{.Name}}},
			{{end}}
		},
		Facets: {{ev}}FacetRetrievers[{{.Type.Name}}]{
			{{range .Type.Fields -}}
				{{FieldTemplate "facet" .}}
			{{- end}}
		},
	}).Query(query)
}

{{range .Type.Fields}}
	{{FieldTemplate "methods" .}}
{{end}}

{{define "facet-string"}}
	{{if .Facet }}
		{{ev}}StringFacet{
			Getter: d.get{{.Name}}, 
			Field: "{{.Name}}", 
			Name: "{{.Facet}}",
		},
	{{end}}
{{end}}
{{define "facet-number"}}{{end}}
{{define "facet-bool"}}{{end}}

{{define "accessor-number"}}
	"{{.Name}}": {{ev}}NumberGetter{Name: "{{.Name}}", Func: d.get{{.Name}}},
{{end}}

{{define "accessor-string"}}
	"{{.Name}}": {{ev}}StringGetter{Name: "{{.Name}}", Func: d.get{{.Name}}},
{{end}}

{{define "accessor-bool"}}
	"{{.Name}}": {{ev}}BooleanGetter{Name: "{{.Name}}", Func: d.get{{.Name}}},
{{end}}

{{define "load"}}
	{{- if eq .Ref.String "time.Time" -}}
	{{.Name}}.Unix()
	{{- else if .Ref.IsStringer -}}
	{{.Name}}.String()
	{{- else -}}
	{{.Name}}
	{{- end -}}
{{end}}

{{define "methods-number"}}
	func (d {{.Of.Name}}Dataset) get{{.Name}}(record int) float64 {
		return float64(d[record].{{template "load" .}})
	}
	{{template "sort" .}}
{{end}}

{{define "methods-string"}}
	func (d {{.Of.Name}}Dataset) get{{.Name}}(record int) string {
		return d[record].{{template "load" .}}
	}
	{{template "sort" .}}
{{end}}

{{define "methods-bool"}}
	func (d {{.Of.Name}}Dataset) get{{.Name}}(record int) bool {
		return d[record].{{.Name}}
	}

	func (_ {{.Of.Name}}Dataset) sortAsc{{.Name}}(left, right {{.Of.Name}}) bool {
		return left.{{.Name}} == right.{{.Name}}
	}

	func (_ {{.Of.Name}}Dataset) sortDesc{{.Name}}(left, right {{.Of.Name}}) bool {
		return left.{{.Name}} != right.{{.Name}}
	}
{{end}}

{{define "sort"}}
	func (_ {{.Of.Name}}Dataset) sortAsc{{.Name}}(left, right {{.Of.Name}}) bool {
		return left.{{template "load" .}} < right.{{template "load" .}}
	}

	func (_ {{.Of.Name}}Dataset) sortDesc{{.Name}}(left, right {{.Of.Name}}) bool {
		return left.{{template "load" .}} > right.{{template "load" .}}
	}
{{end}}
`

func main() {
	// Environment variables:
	//
	// PWD - directory, where the file with //go:generate is placed
	// GOFILE - basename, path.Join(os.Getenv("PWD"), os.Getenv("GOFILE")) to work properly
	// GOLINE - where the //go:generate comment is placed
	// GOPACKAGE - basename of the package, need to resolve go.mod for the full package name
	filename := path.Join(os.Getenv("PWD"), os.Getenv("GOFILE"))
	ds, err := meta.Parse(filename, os.Args[1])
	if err != nil {
		panic(err)
	}
	t := template.New("code")
	t.Funcs(template.FuncMap{
		"ev": func() string {
			// special case for package under test, for simplicity reasons.
			if os.Getenv("GOPACKAGE") == "eval" {
				return ""
			}
			return "eval."
		},
		"FieldTemplate": func(prefix string, field *meta.Field) (string, error) {
			buf := bytes.NewBuffer([]byte{})
			err = t.ExecuteTemplate(buf, fmt.Sprintf("%s-%s", prefix, field.AbstractType()), field)
			return strings.TrimSpace(buf.String()), err
		},
	}).Parse(tmpl)
	dst, err := os.OpenFile(ds.TargetFile, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0755)
	if err != nil {
		panic(err)
	}
	defer dst.Close()
	err = t.Execute(dst, ds)
	if err != nil {
		panic(err)
	}
	err = exec.Command("go", "fmt", ds.TargetFile).Run()
	if err != nil {
		panic(err)
	}
}
